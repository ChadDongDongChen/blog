<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Jetbrains系列产品2019.2最新激活方法(包含IDEA)]]></title>
    <url>%2F2019%2F10%2F22%2F10020-idea%2F</url>
    <content type="text"><![CDATA[9月份突然所有以前激活的都失效了，哥来分享最新的破解方法,该攻略可以激活Jetbrains系列所有产品。最新进展，只能激活2019.3以下版本 所需下载文件链接: https://pan.baidu.com/s/1CFb3A5_17ntThXfodqhesg&shfl=shareset提取码: gsc1 使用方法 下载jar以后随意放到一个文件夹中，复制该文件的绝对路径； 启动你的IDE，如果上来就需要注册，选择：试用（Evaluate for free）进入IDE。第一次安装，没有项目的话，新建一个空项目。 点击你要注册的IDE菜单：”Configure” 或 “Help” -> “Edit Custom VM Options …”，如果提示是否要创建文件，请点”Yes”。 末行添加：-javaagent:/Users/chendong/jetbrains-agent.jar（注意：不要用中文路径） 123456#mac-javaagent:/Users/chendong/jetbrains-agent.jar#linux-javaagent:/home/chendong/jetbrains-agent.jar#windows-javaagent:C:\Users\chendong\jetbrains-agent.jar 重启IDE; 点击IDE菜单 “Help” -> “Register…” 或 “Configure” -> “Manage License…”; 选择License server方式，地址填入：http://jetbrains-license-server （应该会自动填上）;或者点击按钮：”Discover Server”来自动填充地址; 点击激活按钮，激活成功; 声明本攻略只做学习研究之用，不得用于商业用途！ end 😄 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>idea</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring Boot中的缓存支持]]></title>
    <url>%2F2019%2F09%2F29%2F10019-springbootcache%2F</url>
    <content type="text"><![CDATA[Java缓存浅析 随着时间的积累，应用的使用用户不断增加，数据规模也越来越大，往往数据库查询操作会成为影响用户使用体验的瓶颈，此时使用缓存往往是解决这一问题非常好的手段之一。Spring 3开始提供了强大的基于注解的缓存支持，可以通过注解配置方式低侵入的给原有Spring应用增加缓存功能，提高数据访问性能。 在Spring Boot中对于缓存的支持，提供了一系列的自动化配置，使我们可以非常方便的使用缓存。下面我们通过一个简单的例子来展示，我们是如何给一个既有应用增加缓存功能的。 快速入门首先，下载样例工程chapter3-2-2。本例通过spring-data-jpa实现了对User用户表的一些操作，若没有这个基础，可以先阅读《使用Spring-data-jpa简化数据访问层》一文对数据访问有所基础。 准备工作为了更好的理解缓存，我们先对该工程做一些简单的改造。 application.properties文件中新增spring.jpa.properties.hibernate.show_sql=true，开启hibernate对sql语句的打印 修改单元测试ApplicationTests，初始化插入User表一条用户名为AAA，年龄为10的数据。并通过findByName函数完成两次查询。 1234567891011121314151617181920212223@RunWith(SpringJUnit4ClassRunner.class)@SpringApplicationConfiguration(Application.class)public class ApplicationTests { @Autowired private UserRepository userRepository; @Before public void before() { userRepository.save(new User("AAA", 10)); } @Test public void test() throws Exception { User u1 = userRepository.findByName("AAA"); System.out.println("第一次查询：" + u1.getAge()); User u2 = userRepository.findByName("AAA"); System.out.println("第二次查询：" + u2.getAge()); }} 执行单元测试，我们可以在控制台中看到下面内容。12345Hibernate: insert into user (age, name) values (?, ?)Hibernate: select user0_.id as id1_0_, user0_.age as age2_0_, user0_.name as name3_0_ from user user0_ where user0_.name=?第一次查询：10Hibernate: select user0_.id as id1_0_, user0_.age as age2_0_, user0_.name as name3_0_ from user user0_ where user0_.name=?第二次查询：10 在测试用例执行前，插入了一条User记录。然后每次findByName调用时，都执行了一句select语句来查询用户名为AAA的记录。 引入缓存在pom.xml中引入cache依赖，添加如下内容：1234 org.springframework.boot spring-boot-starter-cache 在Spring Boot主类中增加@EnableCaching注解开启缓存功能，如下：123456789@SpringBootApplication@EnableCachingpublic class Application { public static void main(String[] args) { SpringApplication.run(Application.class, args); }} 在数据访问接口中，增加缓存配置注解，如：1234567@CacheConfig(cacheNames = "users")public interface UserRepository extends JpaRepository { @Cacheable User findByName(String name);} 再来执行以下单元测试，可以在控制台中输出了下面的内容：1234Hibernate: insert into user (age, name) values (?, ?)Hibernate: select user0_.id as id1_0_, user0_.age as age2_0_, user0_.name as name3_0_ from user user0_ where user0_.name=?第一次查询：10第二次查询：10 到这里，我们可以看到，在调用第二次findByName函数时，没有再执行select语句，也就直接减少了一次数据库的读取操作。 原文ehcache的使用 end 😄 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>springboot</tag>
        <tag>cache</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[购买二手房注意事项]]></title>
    <url>%2F2019%2F06%2F16%2F10018-ershoufang%2F</url>
    <content type="text"><![CDATA[分享一下。手机最好长按图片保存起来放大看。如果电脑的话右键图片，然后选择在新的页面打开链接。 end 😄 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>二手房</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构笔记]]></title>
    <url>%2F2019%2F04%2F11%2F10017-dataStructure%2F</url>
    <content type="text"><![CDATA[好久没有温习数据结构了，今天来整理整理。 堆栈（stack）堆栈（英语：stack）又称为栈或堆叠，是计算机科学中的一种抽象数据类型，只允许在有序的线性数据集合的一端（称为堆栈顶端，英语：top）进行加入数据（英语：push）和移除数据（英语：pop）的运算。因而按照后进先出（LIFO, Last In First Out）的原理运作。 常与有序的线性数据集合队列相提并论。 堆栈常用一维数组或链表来实现。 软件堆栈堆栈可以用数组和链表两种方式实现，一般为一个堆栈预先分配一个大小固定且较合适的空间并非难事，所以较流行的做法是Stack结构下含一个数组。如果空间实在紧张，也可用链表实现，且去掉表头 堆栈有时候也常用来指代堆栈段。堆栈段（stack segment）通常是指采用堆栈方式工作的一段内存区域。当程序被执行时，程序可能会将其执行的状态加入栈的顶部；当程序结束时，它必须把栈顶的状态数据弹出（pop）。 硬件堆栈架构层次上的堆栈通常被用以申请和访问内存。 队列（queue）队列，又称为伫列（queue），是先进先出（FIFO, First-In-First-Out）的线性表。在具体应用中通常用链表或者数组来实现。队列只允许在后端（称为rear）进行插入操作，在前端（称为front）进行删除操作。 队列的操作方式和堆栈类似，唯一的区别在于队列只允许新数据在后端进行添加。 单链队列单链队列使用链表作为基本数据结构，所以不存在伪溢出的问题，队列长度也没有限制。但插入和读取的时间代价较高 循环队列循环队列可以更简单防止伪溢出的发生，但队列大小是固定的。 链表（link）链表是一种数据结构，和数组同级。比如，Java 中我们使用的 ArrayList，其实现原理是数组。而LinkedList 的实现原理就是链表了。链表在进行循环遍历时效率不高，但是插入和删除时优势明显。 单向链表链表中最简单的一种是单向链表，它包含两个域，一个信息域和一个指针域。这个链接指向列表中的下一个节点，而最后一个节点则指向一个空值。一个单向链表的节点被分成两个部分。第一个部分保存或者显示关于节点的信息，第二个部分存储下一个节点的地址。单向链表只可向一个方向遍历。 链表最基本的结构是在每个节点保存数据和到下一个节点的地址，在最后一个节点保存一个特殊的结束标记，另外在一个固定的位置保存指向第一个节点的指针，有的时候也会同时储存指向最后一个节点的指针。一般查找一个节点的时候需要从第一个节点开始每次访问下一个节点，一直访问到需要的位置。但是也可以提前把一个节点的位置另外保存起来，然后直接访问。当然如果只是访问数据就没必要了，不如在链表上储存指向实际数据的指针。这样一般是为了访问链表中的下一个或者前一个（需要储存反向的指针，见下面的双向链表）节点。 双向链表每个节点有两个连接：一个指向前一个节点，（当此“连接”为第一个“连接”时，指向空值或者空列表）；而另一个指向下一个节点，（当此“连接”为最后一个“连接”时，指向空值或者空列表）双向链表也叫双链表。双向链表中不仅有指向后一个节点的指针，还有指向前一个节点的指针。这样可以从任何一个节点访问前一个节点，当然也可以访问后一个节点，以至整个链表。一般是在需要大批量的另外储存数据在链表中的位置的时候用。双向链表也可以配合下面的其他链表的扩展使用。 循环链表在一个 循环链表中, 首节点和末节点被连接在一起。这种方式在单向和双向链表中皆可实现。要转换一个循环链表，你开始于任意一个节点然后沿着列表的任一方向直到返回开始的节点。再来看另一种方法，循环链表可以被视为“无头无尾”。这种列表很利于节约数据存储缓存， 假定你在一个列表中有一个对象并且希望所有其他对象迭代在一个非特殊的排列下。 指向整个列表的指针可以被称作访问指针。循环链表中第一个节点之前就是最后一个节点，反之亦然。循环链表的无边界使得在这样的链表上设计算法会比普通链表更加容易。对于新加入的节点应该是在第一个节点之前还是最后一个节点之后可以根据实际要求灵活处理，区别不大(详见下面实例代码)。当然，如果只会在最后插入数据（或者只会在之前），处理也是很容易的。 另外有一种模拟的循环链表，就是在访问到最后一个节点之后的时候，手工的跳转到第一个节点。访问到第一个节点之前的时候也一样。这样也可以实现循环链表的功能，在直接用循环链表比较麻烦或者可能会出现问题的时候可以用。 常见用途常用于组织删除、检索较少，而添加、遍历较多的数据。 如果与上述情形相反，应采用其他数据结构或者与其他数据结构组合使用。 数组 (Array)数组（英语：Array），是由相同类型的元素（element）的集合所组成的数据结构，分配一块连续的内存来存储。利用元素的索引（index）可以计算出该元素对应的存储地址。 一维数组一维（或单维）数组是一种线性数组，其中元素的访问是以行或列索引的单一下标表示。 1234567891011121314//JAVA数组的两种创建方式public static void main(String[] args){ int[] arry1 = {1,2,3}; int[] arry2 = new int[3]; arry2[0] = 1; arry2[1] = 2; arry2[2] = 3; for (int i : arry1) { System.out.println(i); } for (int i : arry2) { System.out.println(i); }} 多维数组多维数组就是数组中嵌套数组，我们在多维数组之中采用一系列有序的整数来标注，如在[ 3,1,5 ] 。这种整数列表之中整数的个数始终相同，且被称为数组的“维度”。关于每个数组维度的边界称为“维”。维度为k的数组通常被称为k维。 如下所示： { {0,0,0,1,0,0,0}, {0,0,1,0,1,0,0}, {0,1,0,0,0,1,0}, {1,0,0,0,0,0,1}, {0,1,0,0,0,1,0}, {0,0,1,0,1,0,0}, {0,0,0,1,0,0,0} } 数组特点因为数组在存储数据时是按顺序存储的，存储数据的内存也是连续的，所以他的特点就是寻址读取数据比较容易，插入和删除比较困难。简单解释一下为什么，在读取数据时，只需要告诉数组要从哪个位置（索引）取数据就可以了，数组会直接把你想要的位置的数据取出来给你。插入和删除比较困难是因为这些存储数据的内存是连续的，要插入和删除就需要变更整个数组中的数据的位置。举个例子：一个数组中编号0->1->2->3->4这五个内存地址中都存了数组的数据，但现在你需要往4中插入一个数据，那就代表着从4开始，后面的所有内存中的数据都要往后移一个位置。这可是很耗时的。 程序设计数组设计之初是在形式上依赖内存分配而成的，所以必须在使用前预先请求空间。这使得数组有以下特性： 请求空间以后大小固定，不能再改变（数据溢出问题）； 在内存中有空间连续性的表现，中间不会存在其他程序需要调用的数据，为此数组的专用内存空间； 在旧式编程语言中（如有中阶语言之称的C），程序不会对数组的操作做下界判断，也就有潜在的越界操作的风险（比如会把数据写在运行中程序需要调用的核心部分的内存上）。 树（tree）在计算机科学中，树（英语：tree）是一种抽象数据类型（ADT）或是实现这种抽象数据类型的数据结构，用来模拟具有树状结构性质的数据集合。它是由n（n>0）个有限节点组成一个具有层次关系的集合。把它叫做“树”是因为它看起来像一棵倒挂的树，也就是说它是根朝上，而叶朝下的。 特点 每个节点都只有有限个子节点或无子节点； 没有父节点的节点称为根节点； 每一个非根节点有且只有一个父节点； 除了根节点外，每个子节点可以分为多个不相交的子树； 树里面没有环路(cycle) 无序树树中任意节点的子节点之间没有顺序关系，这种树称为无序树，也称为自由树； 有序树树中任意节点的子节点之间有顺序关系，这种树称为有序树； 二叉树每个节点最多含有两个子树的树称为二叉树； 完全二叉树在一棵二叉树中，除最后一层外，若其余层都是满的，并且最后一层或者是满的，或者是在右边缺少连续若干节点，则此二叉树为完全二叉树（Complete Binary Tree）。 满二叉树这种树的特点是每一层上的节点数都是最大节点数。 将n叉树转换为二叉树二叉树当且仅当根节点没有右子结点时可转换为n叉树。 例如，在左边的树中，A有6个子结点{B,C,D,E,F,G}。它能被转换成右边的二叉树。 将一棵树转换为二叉树的方法： 在兄弟之间加一连线； 对每个结点，除了其左孩子外，去除其与其余孩子之间的联系； 以树的根结点为轴心，将整树顺时针转45度。 平衡二叉树（AVL树）平衡二叉搜索树（英语：Balanced Binary Tree）是一种结构平衡的二叉搜索树，即叶节点高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。它能在O( {\displaystyle \log n} \log n)内完成插入、查找和删除操作，最早被发明的平衡二叉搜索树为AVL树。 常见的平衡二叉搜索树 AVL树 红黑树 Treap 节点大小平衡树 排序二叉树(二叉查找树（英语：Binary Search Tree))二叉查找树（英语：Binary Search Tree），也称为二叉搜索树、有序二叉树（ordered binary tree）或排序二叉树（sorted binary tree），是指一棵空树或者具有下列性质的二叉树： 若任意节点的左子树不空，则左子树上所有节点的值均小于它的根节点的值； 若任意节点的右子树不空，则右子树上所有节点的值均大于它的根节点的值； 任意节点的左、右子树也分别为二叉查找树； 没有键值相等的节点。 霍夫曼树带权路径最短的二叉树称为哈夫曼树或最优二叉树； B树带权路径最短的二叉树称为哈夫曼树或最优二叉树； 图（Graph）图（Graph）用于表示物件与物件之间的关系，是图论的基本研究对象。一张图由一些小圆点（称为顶点或结点）和连结这些圆点的直线或曲线（称为边）组成。稍微通俗易懂一点的阐述 定义二元组定义一张图 {\displaystyle G} G 是一个二元组 {\displaystyle (V,E)} (V,E)，其中 {\displaystyle V} V称为顶点集， {\displaystyle E} E称为边集。它们亦可写成 {\displaystyle V(G)} V(G)和 {\displaystyle E(G)} E(G)。 {\displaystyle E} E的元素是一个二元组数对，用 {\displaystyle (x,y)} (x,y)表示，其中 {\displaystyle x,y\in V} x,y \in V。 三元组定义一张图 {\displaystyle G} G 是一个三元组 {\displaystyle (V,E,I)} (V,E,I)，其中 {\displaystyle V} V称为顶集（Vertices set）， {\displaystyle E} E称为边集（Edges set）， {\displaystyle E} E与 {\displaystyle V} V不相交； {\displaystyle I} I称为关联函数， {\displaystyle I} I将 {\displaystyle E} E中的每一个元素映射到 {\displaystyle V\times V} V\times V。如果 {\displaystyle I(e)=(u,v)(e\in E,u,v\in V)} I(e)=(u,v) (e\in E, u,v \in V)那么称边 {\displaystyle e} e连接顶点 {\displaystyle u,v} u,v，而 {\displaystyle u,v} u,v则称作 {\displaystyle e} e的端点， {\displaystyle u,v} u,v此时关于 {\displaystyle e} e相邻。同时，若两条边 {\displaystyle i,j} i,j有一个公共顶点 {\displaystyle u} u，则称 {\displaystyle i,j} i,j关于 {\displaystyle u} u相邻。 分类有向图和无向图如果给图的每条边规定一个方向，那么得到的图称为有向图，其边也称为有向边。在有向图中，与一个节点相关联的边有出边和入边之分，而与一个有向边关联的两个点也有始点和终点之分。相反，边没有方向的图称为无向图。 简单图 没有两条边，它们所关联的两个点都相同（在有向图中，没有两条边的起点终点都分别相同）； 每条边所关联的是两个不同的顶点满足这两个条件则称为简单图（Simple graph）。 多重图若允许两结点间的边数多于一条，又允许顶点通过同一条边和自己关联，则为多重图的概念。它只能用“三元组的定义”。 散列表（Hash table）散列表（Hash table，也叫哈希表），是根据键（Key）而直接访问在内存存储位置的数据结构。也就是说，它通过计算一个关于键值的函数，将所需查询的数据映射到表中一个位置来访问记录，这加快了查找速度。这个映射函数称做散列函数，存放记录的数组称做散列表。 end 😄 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[博客主动推送到搜索引擎]]></title>
    <url>%2F2019%2F03%2F29%2F10016-blogpush%2F</url>
    <content type="text"><![CDATA[百度主动推送 安装hexo-baidu-url-submit插件 1npm install hexo-baidu-url-submit --save 站点配置文件中添加baidu-url-submit的配置项 123456#设置百度主动推送baidu_url_submit: count: 200 #比如200，代表提交最新的200个链接 host: www.cdd9527.cn # 在百度站长平台中注册的域名，这个改为你自己的域名 token: MrXfdwxcxem6qABX # 请注意这是您的秘钥， 所以请不要把博客源代码发布在公众仓库里! path: baidu_urls.txt # 文本文档的地址， 新链接会保存在此文本文档里，这个默认 百度token获取地址：http://www.sousuoyinqingtijiao.com/baidu/tijiao/ 在站点配置文件中加入新的deploy配置项 1234deploy:- type: git repo: https://gitee.com/dong0719/blog.git- type: baidu_url_submitter 卸载 1npm uninstall hexo-baidu-url-submit 其他其他都有教程http://www.sousuoyinqingtijiao.com/ end 😄 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>博客主动推送</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[spring笔记]]></title>
    <url>%2F2019%2F03%2F27%2F10013-spring%2F</url>
    <content type="text"><![CDATA[介绍spring框架Spring 框架是一个Java平台，它为开发Java应用程序提供全面的基础架构支持。Spring负责基础架构，因此您可以专注于应用程序的开发。 Spring可以让您从“plain old Java objects”（POJO）中构建应用程序和通过非侵入性的POJO实现企业应用服务。此功能适用于Java SE的编程模型，全部的或部分的适应Java EE模型。 中文文档API:https://lfvepclr.gitbooks.io/spring-framework-5-doc-cn/content/2/2-2.html spring特点 轻量级 控制反转 依赖注入和控制反转 Spring框架控制反转（IOC）组件通过提供一系列的标准化的方法把完全不同的组件组合成一个能够使用的应用程序来解决这个问题。Spring框架把形式化的设计模式编写为优秀的对象，你可以容易的集成到自己的应用程序中。许多组织和机构使用Spring框架，以这种方式(使用Spring的模式对象)来设计健壮的，可维护的应用程序。 通俗易懂的一个回答:https://www.zhihu.com/question/32108444. 面向切面 容器 框架集合spring核心组件spring常用模块常用注解 未完待续。。😄 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mac破解百度云盘限速]]></title>
    <url>%2F2019%2F03%2F27%2F10014-baiducloud%2F</url>
    <content type="text"><![CDATA[现在市场上网盘就百度一家独大了，为了赚钱限制下载速度，一个1G的文件下载速度几十KB每秒，如果不开会员，可能要下一天，要是着急的话简直想砸电脑，简直不能忍，此时贴心的百度会给你推荐，请付费升级到会员，畅享高速，最终只能开个会员了。对于我这种月光族的人来说，能省就省吧。进入正题！！ 两个工具一、Chrome插件:网盘助手 链接: https://pan.baidu.com/s/1mreRqTlTzwjmiEd9o1m83A 提取码: pckp 下载后直接将文件夹拖进去最终在谷歌插件列表中出现一个这样的图标二、开源软件: Aria2GUI 链接: https://github.com/yangshun1029/aria2gui 解压后直接拖到应用里面运行即可 接下来你重启浏览器，进入下载页面时会多出一个“导出下载”按钮。选第一个就ok了，打完收工！ end 😄 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });]]></content>
      <categories>
        <category>mac</category>
      </categories>
      <tags>
        <tag>mac</tag>
        <tag>百度云破解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Guava——Joiner]]></title>
    <url>%2F2019%2F03%2F27%2F10015-joiner%2F</url>
    <content type="text"><![CDATA[Joiner字符串拼接对象 on方法 on 以空格为分隔符 join内是拼接的对象:迭代器对象、数组、可变参数等 12345678910111213141516171819//例子Joiner.on(" ").join("四川省","成都市","金牛区").toString();//result四川省 成都市 金牛区//动态拼接StringBuffer result = new StringBuffer("result: "); Joiner.on(" ").appendTo(result,7,8);//result7 8//直接忽略NullJoiner.on(" ").skipNulls().join("四川省","成都市","金牛区",null).toString()//找出Null，并用其他值代替Joiner.on(" ").useForNull("未填写").join("四川省","成都市","金牛区",null).toString()//result四川省 成都市 金牛区 四川省 成都市 金牛区 未填写 Joiner.MapJoiner MapJoiner 是 Joiner 的内部静态类，用于帮助将 Map 对象拼接成字符串。123456789101112131415//例子1Joiner.on(" ").withKeyValueSeparator("=").join(ImmutableMap.of("收件人","Nimo","联系方式","123","收件地址","浙江省杭州市滨江区XXXX"));//result收件人=Nimo 联系方式=123 收件地址=浙江省杭州市滨江区XXXX//例子2Map testMap = Maps.newLinkedHashMap();testMap.put("Washington D.C", "Redskins");testMap.put("New York City", "Giants");testMap.put("Philadelphia", "Eagles");testMap.put("Dallas", "Cowboys");String returnedString = Joiner.on("#").withKeyValueSeparator("=").join(testMap);System.out.println(returnedString);//resultWashington D.C=Redskins#New York City=Giants#Philadelphia=Eagles#Dallas=Cowboys end 😄 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java8</tag>
        <tag>Joiner</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JVM学习]]></title>
    <url>%2F2018%2F11%2F08%2F10011-jvm%2F</url>
    <content type="text"><![CDATA[#JVM简介我们都知道 Java 源文件，通过编译器，能够生产相应的.Class 文件，也就是字节码文件， 而字节码文件又通过 Java 虚拟机中的解释器，编译成特定机器上的机器码 。 大概顺序是: Java 源文件—->编译器—->字节码文件—->JVM—->机器码 每一种平台的解释器是不同的，但是实现的虚拟机是相同的，这也就是 Java 为什么能够 跨平台的原因了 ，当一个程序从开始运行，这时虚拟机就开始实例化了，多个程序启动就会 存在多个虚拟机实例。程序退出或者关闭，则虚拟机实例消亡，多个虚拟机实例之间数据不能共享。 Hotspot JVM 后台运行的系统线程主要有下面几个: 虚拟机线程 (VM thread)这个线程等待 JVM 到达安全点操作出现。这些操作必须要在独立的线程里执行，因为当 堆修改无法进行时，线程都需要 JVM 位于安全点。这些操作的类型有:stop-the- world 垃圾回收、线程栈 dump、线程暂停、线程偏向锁(biased locking)解除。 周期性任务线程这线程负责定时器事件(也就是中断)，用来调度周期性操作的执行。 GC 线程这些线程支持 JVM 中不同的垃圾回收活动。 编译器线程这些线程在运行时将字节码动态编译成本地平台相关的机器码。 信号分发线程这个线程接收发送到 JVM 的信号并调用适当的 JVM 方法处理。 线程这里所说的线程指程序执行过程中的一个线程实体。JVM 允许一个应用并发执行多个线程。Hotspot JVM 中的 Java 线程与原生操作系统线程有直接的映射关系。当线程本地存储、缓 冲区分配、同步对象、栈、程序计数器等准备好以后，就会创建一个操作系统原生线程。 Java 线程结束，原生线程随之被回收。操作系统负责调度所有线程，并把它们分配到任何可 用的 CPU 上。当原生线程初始化完毕，就会调用 Java 线程的 run() 方法。当线程结束时，会释放原生线程和 Java 线程的所有资源。 所谓虚拟机，就足一台虚拟的机器。它是一款软件，用来执行一系列虚拟计算机指令，大体上虚拟机可以分为系统虚拟机和程序虚拟机，大名鼎鼎的Visual Box、VMare就A4于系统虚拟机，他们完全是对物理计算机的仿真，提供个可运行完整操作系统的软件f台•程序虚拟机典犁代表就是Java虚拟机，它专f〗为执行单个U•算机程序iW设汁，在java虚拟机中执行的指令我们成为java字节码指令•无论是系统虚拟机还是程序虚拟机，在上面运行的软件都被限制子虚拟机提供的资源中.Java发展至今，出现过很多虚拟机,最初Sun使用的一款叫Classic的Java虚拟机，到现在引用最广泛的是HotSpot虚拟机，除了Sun意外，还有BEA的JRockit, 目前JRockit和 Hotspot都被Oracle收入旗下，大有整合的趋势. 类加载子系统负责从文件系统或者网络中加载Class信息，加载的信息存放在一块称之为方法区的内存空间。 方法区就是存放类信息、常量信息、常量池信息、包括字符串字面量和数字常量等。 堆在java虚拟机启动的时候建立java堆，它是java程序最主要的内存工作区域，几乎所有的对象实例都存放到java堆中，堆空间是所有线程共享的。 直接内存java的NIO库允许java程序使用直接内存，从而提高性能，通常直接内存速度会优于java堆。读写频繁的场合可能会考虑使用。 栈每个虚拟机线程都有一个私有的栈，一个线程的java栈在线程创建的时候被创建，java栈中保存着局部变量、方法参数、同时java的方法调用、返回值等。 本地方法栈本地方法栈和java栈非常类似，最大不同为本地方法栈用于本地方法调用。java虚拟机允许java直接调用本地方法（通常使用C编写） 垃圾收集系统垃圾收集系统是java的核心，也是必不可少的，java有一套自己进行垃圾清理的机制，开发人员无需手动清理。 PC寄存器PC(Program Counter)寄存器也是每个线程私有的空间，java虚拟机会为每个线程创建PC寄存器，在任意时刻，一个java线程总是在执行一个方法，这个方法被称为当前方法，如果当前方法不是本地方法，PC寄存器就会执行当前正在被执行的指令，如果是本地方法，则PC寄存器值为undefined，寄存器存放入当前执行环节指针、程序计数器、操作栈指针、计算的变量指针等信息。 执行引擎组件虚拟机最核心的组件就是执行引擎了，它负责执行虚拟机的字节码。一般会先进行编译成机器码后执行 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>jvm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[日志体系]]></title>
    <url>%2F2018%2F11%2F08%2F10012-log%2F</url>
    <content type="text"><![CDATA[日志种类 log4j log4j2 jcl(底层调用的是log4j) slf4j logback jul(jdk自带的) simplelog 未完待续！ document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>日志</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[和吕:高山茶籽油]]></title>
    <url>%2F2018%2F10%2F23%2F10010-chayou%2F</url>
    <content type="text"><![CDATA[和吕村介绍和吕村地处罗霄山脉中段地带，崇山俊岭，与井岗山山脉相连，最高山峰海拔1344米,略高于1300米的南岳衡山。属茶陵县与井岗山市交接处，从山顶向四周眺望，众山尽收眼底，云山雾绕，风景秀丽，不亚于南岳衡山； 石峰仙 云海 茶油功效野山茶油又名油茶籽油、山茶油，是纯天然高级木本食用油。油茶树生长在亚热带南岭湿润气候区，整个生长过程无需化肥、农药等辅助手段。山茶果生长期从开花到成熟，历经秋、冬、春、夏、四季之雨露，尽吸天然养份、日月精华，营养价值极高。是《中国食物结构改革与发展规划纲要》中大力提倡推广的食用植物油，也是国际粮农组织首推的卫生保健植物食用油。 保护皮肤 减肥功效 去除妊娠纹 防眼角皱纹 美白护肤 治疗暗疮 保持女性的体态美 补充维生素 详情可以看百度介绍油茶籽油 茶油种植地实拍图 感谢观看！产地直销，没有中间商赚差价，需要的可以留下联系方式或者长按二维码联系。😄😄😄 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>和吕</tag>
        <tag>茶籽油</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Centos安装msql并可以远程连接]]></title>
    <url>%2F2018%2F08%2F27%2F10009-mysql%2F</url>
    <content type="text"><![CDATA[在CentOS中默认安装有MariaDB，这个是MySQL的分支，但为了需要，还是要在系统中安装MySQL，而且安装完成之后可以直接覆盖掉MariaDB。 安装mysql（由于yum源上没有mysql-server。所以必须去官网下载，这里 我们用wget命令，直接获取） wget -i -c http://dev.mysql.com/get/mysql57-community-release-el7-10.noarch.rpm 安装mysql的依赖包yum -y install mysql57-community-release-el7-10.noarch.rpm 安装mysql数据库yum -y install mysql-community-server 完成安装，重启mysqlsystemctl restart mysqld 此时MySQL已经开始正常运行，不过要想进入MySQL还得先找出此时root用户的密码，通过如下命令可以在日志文件中找出密码： grep "password" /var/log/mysqld.log 复制粘贴上边的密码进入数据库mysql -uroot -p 输入初始密码，此时不能做任何事情，因为MySQL默认必须修改密码之后才能操作数据库修改密码命令： ALTER USER ‘root‘@’localhost’ IDENTIFIED BY ‘123’; 解决报错以上报错是说新设置的密码过于简单，解决方式：//首先按照默认密码格式复杂度更改 查看MySQL完整的初始密码规则查看MySQL完整的初始密码规则，查看的前提是必须先用ALTER USER命令更改过密码 SHOW VARIABLES LIKE 'validate_password%'; 修改MySQL默认策略和密码长度因为当前的密码太复杂不方便后期做实验，所以使用命令修改密码策略两种方式： set global validate_password_policy=0; set global validate_password_policy=LOW; 注：密码策略分四种1、OFF（关闭） 2、LOW（低） 3、MEDIUM（中） 4、STRONG（强） 修改密码长度 上边改完策略之后我们在改长度 SET GLOBAL validate_password_length=4; 查看密码规则都改完之后查看密码规则 SHOW VARIABLES LIKE 'validate_password%'; 接下来就可以将刚才的复杂密码改为简单的四位的密码了； 卸载安装源自动更新此时还有一个问题，就是因为安装了Yum Repository，以后每次yum操作都会自动更新，因为当前数据库已安装完成，所以把这个卸载掉： yum remove mysql57-community-release.noarch 初始化数据库mysql_secure_installation 注：执行完初始化命令后需要输入数据库root用户密码，然后默认如上截图一路回车即可。（以上截图问题也可根据自己实际情况进行选择） 开启MySQL远程访问权限 允许远程连接登陆mysql数据库mysql -u root -p 查看user表use mysql select host,user,password from user; 可以看到在user表中已创建的root用户。host字段表示登录的主机，其值可以用IP，也可用主机名，有时想用本地IP登录，那么可以将以上的Host值改为自己的Ip即可。 实现远程连接(授权法)将host字段的值改为%就表示在任何客户端机器上能以root用户登录到mysql服务器，建议在开发时设为%。将权限改为ALL PRIVILEGES grant all privileges on *.* to root@'%' identified by "你的密码"; flush privileges; select host,user,password from user; 实现远程连接（改表法）update user set host = ’%’ where user = ’root’; Linux下彻底卸载mysql详解使用以下命令查看当前安装mysql情况，查找以前是否装有mysql rpm -qa|grep -i mysql 停止mysqlsystemctl stop mysqld 删除rpm -ev MySQL-client-5.5.25a-1.rhel5 如果提示依赖包错误，则使用以下命令尝试 rpm -ev MySQL-client-5.5.25a-1.rhel5 --nodeps 如果提示错误：error: %preun(xxxxxx) scriptlet failed, exit status 1 rpm -e --noscripts MySQL-client-5.5.25a-1.rhel5 查找之前老版本mysql的目录、并且删除老版本mysql的文件和库find / -name mysql rm -rf /var/lib/mysql 注意：卸载后/etc/my.cnf不会删除，需要进行手工删除 rm -rf /etc/my.cnf 再次查找机器是否安装mysqlrpm -qa|grep -i mysql end 😄 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });]]></content>
      <categories>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[湖南茶陵可可农家:家的味道]]></title>
    <url>%2F2018%2F08%2F21%2F10008-keke%2F</url>
    <content type="text"><![CDATA[作为标准的吃货一枚 对美食那是从来都不愿错过的 在咱们茶陵 就有很多好吃的农家手工小吃 下面就大家去看一看 不知道是否有你也爱吃的 先来一波家乡的美照图，所有的农产品都来自这个山清水秀的地方! 正题来了,我觉得好吃的都列在下面了。 No.1 香辣河鱼 No.2 香辣河虾 No.3 香辣泥鳅 No.4 盐辣椒 No.5 豆豉鱼块 No.6 茶油霉豆腐 No.7 手工米粉 No.8 香辣萝卜条 看了后是不是一直在吞口水，哈哈~ 以上全都是手工制作 来看看制作的花絮吧 制作花絮 炸泥鳅 刚打捞回来的小河鱼 做米粉 捞河鱼 想吃的话，赶紧找我或者下面这个人吧 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>可可农家</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git实战]]></title>
    <url>%2F2018%2F08%2F20%2F10006-git%2F</url>
    <content type="text"><![CDATA[Git保存用户名密码走过路过不要错过，江南皮革厂倒闭啦！有点跑题了… 在linux上使用git，每次操作都需要输入账号密码，您是不是觉得特别烦恼？不用怕。 1.clone下来项目后用ls -a语句查询看有没有隐藏文件夹，如下 2.输入vim .git/config添加这两行 [credential] helper = store效果如下 3.再去git pull等操作时只要第一次输入正确账号密码，后面就会一直记住密码啦！ Git常用命令总结部分内容转自: https://blog.csdn.net/tomatozaitian/article/details/73515849 安装及配置：Ubuntu下安装： sudo apt-get install git 配置用户名： git config --global user.name "你的名字" 配置e-mail： git config --global user.email "你的邮箱@xx.com" 与添加有关的：将当前目录变为仓库： git init 将文件添加到暂存区： git add 文件名 [可选：另一个文件名] 将暂存区提交到仓库： git commit –m "描述" 与查询有关的：查询仓库状态： git status 比较文件差异（请在git add之前使用）： git diff 文件名 查看仓库历史记录(详细)： git log 查看仓库历史记录(单行)： git log --pretty=online 或 git log --online 查看所有版本的commit ID： git reflog 与撤销有关的：撤销工作区的修改： git checkout -- 文件名 撤销暂存区的修改： git reset HEAD 文件名 回退到历史版本： git reset --hard 该版本ID 回退到上个版本： git reset --hard HEAD^ //上上版本是HEAD^^，也可用HEAD~2表示，以此类推 与标签有关的：为当前版本打标签： git tag 标签名 为历史版本打标签： git tag 标签名 该版本ID 指定标签说明： git tag –a 标签名 –m "标签说明" [可选：版本ID] 查看所有标签： git tag 查看某一标签： git show 标签名 删除某一标签： git tag –d 标签名 与分支有关创建分支 git branch dev 切换分支 git checkout dev 创建分支并切换分支 git checkout -b dev 删除分支 git branch -d dev 在分支上提交新的版本 git commit -a -m 'dev1' 合并分支 git merge dev 分支的合并后显示log git log --oneline --graph --decorate 在分支开发的过程中遇到其他问题需要切换其他分支保留写好的内容在切换到主干保留内容 git stash 在次切换分之后需要应用一下保留的内容 git stash apply 丢掉保存的内容 git stash drop 使用并丢掉 git stash pop -有的时候开发需要合并指定的内容，而不是合并所有的提交，所以我们需要挑选最好的，自己生产版本 合并分支把树杈掰到主干上 git rebase 添加远程的仓库 push -u //-u参数 upstream git push origin master -u //获取最新代码 git remote add origin 仓库的地址 查看远程仓库 git remote -v 删除远程仓库 git remote rm origin 其它记录一般配置 git --version //查看git的版本信息 git config --global user.name //获取当前登录的用户 git config --global user.email //获取当前登录用户的邮箱 登录git /* 如果刚没有获取到用户配置，则只能拉取代码，不能修改 要是使用git，你要告诉git是谁在使用*/ git config --global user.name 'userName' //设置git账户，userName为你的git账号， git config --global user.email 'email' 创建一个文件夹 mkdir nodejs //创建文件夹nodejs cd nodejs //切换到nodejs目录下 初始化git仓库 git init //在nodejs文件夹下初始化一个仓库，此时文件里会到一个.git的隐藏文件夹 创建忽略文件 touch .gitignore //不需要服务器端提交的内容可以写到忽略文件里 /* .git .idea */ 查看目录 ls -al 创建文件并写入内容 //如果文件不存在则会创建文件 echo "hello git" > index.html //将'hello git' 写入到index.html中 //单个>箭头表示写入， >>表示追加 查看文件内容 cat index.html 增加到暂存区中 git add index.html git add -A //全部添加到缓存区 增加到版本库中 git commit -m '备注信息' 查看版本 git log --oneline 比较差异比较的是暂存区和工作区的差异 git diff 比较的是暂存区和历史区的差异 git diff --cached 比较的是历史区和工作区的差异（修改） git diff master 撤回内容(如果修改了工作区的文件后发现改错了，可以用暂存区或者版本库里的文件替换掉工作区的文件)用暂存区中的内容或者版本库中的内容覆盖掉工作区 git checkout index.html 取消增加到暂存区的内容（添加时） git reset HEAD index.html //显示目录的状体 有没有添加或者修改文件 git status 删除本地文件 rm fileName 删除暂存区保证当前工作区中没有index.html git rm index.html --cached 使用--cached 表示只删除缓存区中的内容 回滚版本回滚最近的一个版本 git log git reset --hard HEAD/commit_id 回滚到未来 git reflog document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>centeros</tag>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[超级实用的谷歌插件]]></title>
    <url>%2F2018%2F08%2F01%2F10007-google%2F</url>
    <content type="text"><![CDATA[自己定义的排行榜 AdBlock 当之无愧的NO.1能拦截所有的广告，包括播放器的广告 Tampermonkey 捣蛋的猴子？？我一般用来破解百度云盘下载限速用的，里面有各种各样的脚本。 新浪微博图床 免费的图片服务器 Proxy SwitchyOmega 一个自动代理的工具 目前用的最多的就这四个，以后还有好东西再更新。😄 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });]]></content>
      <tags>
        <tag>google</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用mongodb]]></title>
    <url>%2F2018%2F07%2F30%2F10005-mongodb%2F</url>
    <content type="text"><![CDATA[SpringBoot集成mongodb 添加maven依赖1234 org.springframework.boot spring-boot-starter-data-mongodb 连接配置下列配置包含集群与非集群，具体含义可以自行百度。 123456spring: profiles: jiaowu data: mongodb: uri: mongodb://jiaoxueUser:fieXeiCh4Uqu@dds-uf6177cc6dec7d741.mongodb.rds.aliyuncs.com:3717,dds-uf6177cc6dec7d742.mongodb.rds.aliyuncs.com:3717/jiaoxue?authSource=jiaoxue;replicaSet=mgset-5439253 #uri: mongodb://jiaoxueUser:fieXeiCh4Uqu@dds-uf6177cc6dec7d741.mongodb.rds.aliyuncs.com:3717/jiaoxue?authSource=jiaoxue 现在可以美滋滋的使用MongoTemplate了 mongoDb使用mongoexport导出mongoexport关键参数介绍 -h,–host ：代表远程连接的数据库地址，默认连接本地Mongo数据库； –port：代表远程连接的数据库的端口，默认连接的远程端口27017； -u,–username：代表连接远程数据库的账号，如果设置数据库的认证，需要指定用户账号； -p,–password：代表连接数据库的账号对应的密码； -d,–db：代表连接的数据库； -c,–collection：代表连接数据库中的集合； -f, –fields：代表集合中的字段，可以根据设置选择导出的字段； –type：代表导出输出的文件类型，包括csv和json文件； -o, –out：代表导出的文件名； -q, –query：代表查询条件； –skip：跳过指定数量的数据； –limit：读取指定数量的数据记录； –sort：对数据进行排序，可以通过参数指定排序的字段，并使用 1 和 -1 来指定排序的方式，其中 1 为升序排列，而-1是用于降序排列,如sort({KEY:1})。 windows安装mongodb有linux的真不推荐在windows上装mongodb，因为太多坑了。linux安装我就不说了，直接上windows的安装步骤吧。 下载安装第一坑来了，只要安装3.4以上的版本,就会一直卡住安装不了,所以还是乖乖的安装mongodb3.4以下的吧，点击这里下载 配置然后配置又是问题参考http://www.cnblogs.com/lsc183/archive/2012/08/16/mongodb.html 才配好。 1 添加安装路径到path环境变量： C:\Program Files\MongoDB\Server\3.4\bin 2 创建两个文件夹 D:\mongodb\data D:\mongodb\data\logs 3 创建服务（开机自启动） win+R cmd启动控制台 cd C:\Program Files\MongoDB\Server\3.4\bin mongod.exe –dbpath=D:\mongodb\data –logpath=D:\mongodb\logs\mongodb.log –install 4 启动服务 net start mongodb 5 在浏览器 输入 http://localhost:27017/ 看见It looks like you are trying to access MongoDB over HTTP on the native driver port. 表示成功 MongoDb聚合去这个网站学习下语法:http://www.runoob.com/mongodb/mongodb-aggregate.html MongoDb实战记录一些遇到坑的解决方案。 添加时区由于mongodb的问题,通过程序传进来的日期会有时区问题，所以需要在程序中处理时区问题。1sdf.setCalendar(new GregorianCalendar(new SimpleTimeZone(0, "GMT"))); 通过某些条件将B属性转换到A属性1234567891011121314151617181920212223242526272829303132333435363738db.getCollection('questionInfo').find({ "$and": [{ "question.isenabled": true }, { "question.virtual": 0 }, { "content.questionid": { "$exists": true } }, { "question.score": { "$gt": 0 } }, { "evaluations.questionId": { "$exists": true } }, { "question.audituser": { "$exists": true } } ]}).forEach(function(u) { if(u.question.addLabelDate == null){ var date = u.question.updateDate; if(date != null){ db.getCollection('questionInfo').update({"_id":u._id},{$set:{"question.addLabelDate": date}}) }else{ db.getCollection('questionInfo').update({"_id":u._id},{$set:{"question.addLabelDate": u.question.createTime}}) } }}); document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });]]></content>
      <categories>
        <category>mongodb</category>
      </categories>
      <tags>
        <tag>mongodb</tag>
        <tag>springboot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[推荐一部好看的动画片]]></title>
    <url>%2F2018%2F06%2F29%2F10003-movie%2F</url>
    <content type="text"><![CDATA[开局一张图 🎥 简介在远离大都会的小山村，住着巫女世家出身的高中女孩宫水三叶（上白石萌音 配音）。校园和家庭的原因本就让她充满烦恼，而近一段时间发生的奇怪事件，又让三叶摸不清头脑。不知从何时起，三叶在梦中就会变成一个住在东京的高中男孩。那里有陌生的同学和朋友，有亲切的前辈和繁华的街道，一切都是如此诱人而真实。另一方面，住在东京的高中男孩立花泷（神木隆之介 配音）则总在梦里来到陌生的小山村，以女孩子的身份过着全新的生活。许是受那颗神秘彗星的影响，立花和三叶在梦中交换了身份。他们以他者的角度体验着对方的人生，这期间有愤怒、有欢笑也有暖心。只是两人并不知道，身份交换的背后隐藏着重大而锥心的秘密… 视频 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });]]></content>
      <categories>
        <category>电影</category>
      </categories>
      <tags>
        <tag>东哥推荐</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo整合emoji]]></title>
    <url>%2F2018%2F06%2F28%2F10004-emoji%2F</url>
    <content type="text"><![CDATA[想不想让你的博客支持这样的表情？ 😄😃😏😟😑 :smile: :smiley: :smirk: :worried: :expressionless: 这样 😩😅😥😭😂 :weary: :sweat_smile: :disappointed_relieved: :sob: :joy: 还有这样 😱😠😤😎😈 :scream: :angry: :triumph: :sunglasses: :smiling_imp: 敲黑板！看这里！！ 一共两种方式 第一种（改动markdown渲染模板）这种方式有问题，改了之后会对渲染文章的时候文章标题点击无效。 安装markdown-it把原来的hexo渲染换成基于markdown-it的渲染。 12345npm un hexo-renderer-marked --savenpm i hexo-renderer-markdown-it --savenpm install markdown-it-emoji --save 配置hexo的_config.yml文件在hexo的配置文件下添加markdown-it配置代码： markdown: render: html: true xhtmlOut: false breaks: true linkify: true typographer: true quotes: '“”‘’' plugins: - markdown-it-abbr - markdown-it-footnote - markdown-it-ins - markdown-it-sub - markdown-it-sup - markdown-it-emoji #用emoji插件 anchors: level: 2 collisionSuffix: 'v' permalink: true permalinkClass: header-anchor permalinkSymbol: ¶ 第二种在 Hexo 中默认的 markdown 渲染器是 hexo-renderer-marked ，这个渲染器是不支持 emoji 表情的。 安装1npm install hexo-filter-github-emojis --save 配置在主题中添加配置123456githubEmojis: enable: true className: github-emoji unicode: false styles: localEmojis: finish !!! document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>emoji</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Markdown 编辑器语法指南]]></title>
    <url>%2F2018%2F06%2F28%2F10002-Markdown%2F</url>
    <content type="text"><![CDATA[基本技巧代码如果你只想高亮语句中的某个函数名或关键字，可以使用 function_name() 实现 通常编辑器根据代码片段适配合适的高亮方法，但你也可以用 123456```javascript$(document).ready(function () { alert('hello world');}); 支持的语言：1c, abnf, accesslog, actionscript, ada, apache, applescript, arduino, armasm, asciidoc, aspectj, autohotkey, autoit, avrasm, awk, axapta, bash, basic, bnf, brainfuck, cal, capnproto, ceylon, clean, clojure, clojure-repl, cmake, coffeescript, coq, cos, cpp, crmsh, crystal, cs, csp, css, d, dart, delphi, diff, django, dns, dockerfile, dos, dsconfig, dts, dust, ebnf, elixir, elm, erb, erlang, erlang-repl, excel, fix, flix, fortran, fsharp, gams, gauss, gcode, gherkin, glsl, go, golo, gradle, groovy, haml, handlebars, haskell, haxe, hsp, htmlbars, http, hy, inform7, ini, irpf90, java, javascript, json, julia, kotlin, lasso, ldif, leaf, less, lisp, livecodeserver, livescript, llvm, lsl, lua, makefile, markdown, mathematica, matlab, maxima, mel, mercury, mipsasm, mizar, mojolicious, monkey, moonscript, n1ql, nginx, nimrod, nix, nsis, objectivec, ocaml, openscad, oxygene, parser3, perl, pf, php, pony, powershell, processing, profile, prolog, protobuf, puppet, purebasic, python, q, qml, r, rib, roboconf, rsl, ruby, ruleslanguage, rust, scala, scheme, scilab, scss, smali, smalltalk, sml, sqf, sql, stan, stata, step21, stylus, subunit, swift, taggerscript, tap, tcl, tex, thrift, tp, twig, typescript, vala, vbnet, vbscript, vbscript-html, verilog, vhdl, vim, x86asm, xl, xml, xquery, yaml, zephir 也可以使用 4 空格缩进，再贴上代码，实现相同的的效果 def g(x): yield from range(x, 0, -1) yield from range(x) 如你不需要代码高亮，可以用下面的方法禁用： 1 标题文章内容较多时，可以用标题分段： 标题1 ====== 标题2 ----- ## 大标题 ## ### 小标题 ### 粗斜体*斜体文本* _斜体文本_ **粗体文本** __粗体文本__ ***粗斜体文本*** ___粗斜体文本___ 链接常用链接方法 文字链接 [链接名称](http://链接网址) 网址链接 高级链接技巧 这个链接用 1 作为网址变量 [Google][1]. 这个链接用 yahoo 作为网址变量 [Yahoo!][yahoo]. 然后在文档的结尾为变量赋值（网址） [1]: http://www.google.com/ [yahoo]: http://www.yahoo.com/ https://segmentfault.com/markdown#articleHeader15 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });]]></content>
      <tags>
        <tag>.md</tag>
        <tag>Markdown</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[建站第一篇文章]]></title>
    <url>%2F2018%2F06%2F28%2F10001-hello-world%2F</url>
    <content type="text"><![CDATA[建站的准备hexo搭建安装Git Bash 下载地址 安装NodeJsHexo是基于nodeJS环境的静态博客，里面的npm工具很有用啊，所以还是老老实实把这玩意儿装了吧。下载地址 安装hexo找个文件夹用来放博客，右键打开Git bash here输入命令 npm install -g hexo-cli hexo i blog //init的缩写 blog是项目名 cd blog //切换到站点根目录 hexo g //generetor的缩写 hexo s //server的缩写 打开浏览器输入localhost:4000查看，默认的比较丑。需要更换主题的可以去这里找https://hexo.io/themes/（ps:需要github账号才能下载使用） 我喜欢的主题地址： https://github.com/LouisBarranqueiro/hexo-theme-tranquilpeak document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
</search>
